package azure

import (
	"context"
	"time"

	"github.com/turbot/steampipe-plugin-sdk/v5/grpc/proto"
	"github.com/turbot/steampipe-plugin-sdk/v5/plugin"
	"github.com/turbot/steampipe-plugin-sdk/v5/plugin/transform"

	"github.com/Azure/azure-sdk-for-go/profiles/2020-09-01/monitor/mgmt/insights"
)

//// TABLE DEFINITION

func tableAzureMonitorActivityLogEvent(_ context.Context) *plugin.Table {
	return &plugin.Table{
		Name:        "azure_monitor_activity_log_event",
		Description: "Azure Monitor Activity Log Event",
		List: &plugin.ListConfig{
			Hydrate: listMonitorActivityLogEvents,
			KeyColumns: plugin.KeyColumnSlice{
				{
					Name:      "event_timestamp",
					Require:   plugin.Optional,
					Operators: []string{">", "<", ">=", "<="},
				},
				{
					Name:      "resource_group",
					Require:   plugin.Optional,
					Operators: []string{"="},
				},
				{
					Name:      "correlation_id",
					Require:   plugin.Optional,
					Operators: []string{"="},
				},
				{
					Name:      "resource_id",
					Require:   plugin.Optional,
					Operators: []string{"="},
				},
				{
					Name:      "resource_provider_name",
					Require:   plugin.Optional,
					Operators: []string{"="},
				},
			},
		},
		Columns: azureColumns([]*plugin.Column{
			{
				Name:        "id",
				Description: "The ID of this event as required by ARM for RBAC. It contains the EventDataID and a timestamp information.",
				Type:        proto.ColumnType_STRING,
				Transform:   transform.FromGo(),
			},
			{
				Name:        "caller",
				Description: "The email address of the user who has performed the operation, the UPN claim or SPN claim based on availability.",
				Type:        proto.ColumnType_STRING,
			},
			{
				Name:        "description",
				Description: "The description of the event.",
				Type:        proto.ColumnType_STRING,
				Transform:   transform.FromField("Description").Transform(transform.ToString),
			},
			{
				Name:        "event_data_id",
				Description: "The event data ID. This is a unique identifier for an event.",
				Type:        proto.ColumnType_STRING,
				Transform:   transform.FromField("EventDataID"),
			},
			{
				Name:        "correlation_id",
				Description: "The correlation ID, usually a GUID in the string format. The correlation ID is shared among the events that belong to the same Uber operation.",
				Type:        proto.ColumnType_STRING,
				Transform:   transform.FromField("CorrelationID"),
			},
			{
				Name:        "level",
				Description: "The event level. Possible values include: 'EventLevelCritical', 'EventLevelError', 'EventLevelWarning', 'EventLevelInformational', 'EventLevelVerbose'.",
				Type:        proto.ColumnType_STRING,
			},
			{
				Name:        "resource_id",
				Description: "The resource URI that uniquely identifies the resource that caused this event.",
				Type:        proto.ColumnType_STRING,
				Transform:   transform.FromField("ResourceID"),
			},
			{
				Name:        "operation_id",
				Description: "It is usually a GUID shared among the events corresponding to single operation. This value should not be confused with EventName.",
				Type:        proto.ColumnType_STRING,
				Transform:   transform.FromField("OperationID"),
			},
			{
				Name:        "event_timestamp",
				Description: "The timestamp of when the event was generated by the Azure service processing the request corresponding the event.",
				Type:        proto.ColumnType_TIMESTAMP,
				Transform:   transform.FromField("EventTimestamp").Transform(convertDateToTime),
			},
			{
				Name:        "submission_timestamp",
				Description: "The timestamp of when the event became available for querying via this API.",
				Type:        proto.ColumnType_TIMESTAMP,
				Transform:   transform.FromField("SubmissionTimestamp").Transform(convertDateToTime),
			},
			{
				Name:        "event_name",
				Description: "The event name. This value should not be confused with OperationName. For practical purposes, OperationName might be more appealing to end users.",
				Type:        proto.ColumnType_STRING,
				Transform:   transform.FromField("EventName.Value"),
			},
			{
				Name:        "category",
				Description: "The event category.",
				Type:        proto.ColumnType_STRING,
				Transform:   transform.FromField("Category.Value"),
			},
			{
				Name:        "resource_provider_name",
				Description: "The resource provider name of the impacted resource.",
				Type:        proto.ColumnType_STRING,
				Transform:   transform.FromField("ResourceProviderName.Value"),
			},
			{
				Name:        "resource_type",
				Description: "The resource type.",
				Type:        proto.ColumnType_STRING,
				Transform:   transform.FromField("ResourceType.Value"),
			},
			{
				Name:        "operation_name",
				Description: "The operation name.",
				Type:        proto.ColumnType_STRING,
				Transform:   transform.FromField("OperationName.Value"),
			},
			{
				Name:        "status",
				Description: "A string describing the status of the operation. Some typical values are: Started, In progress, Succeeded, Failed, Resolved.",
				Type:        proto.ColumnType_STRING,
				Transform:   transform.FromField("Status.Value"),
			},
			{
				Name:        "sub_status",
				Description: "The event sub status. Most of the time, when included, this captures the HTTP status code of the REST call. Common values are: OK (HTTP Status Code: 200), Created (HTTP Status Code: 201), Accepted (HTTP Status Code: 202), No Content (HTTP Status Code: 204), Bad Request(HTTP Status Code: 400), Not Found (HTTP Status Code: 404), Conflict (HTTP Status Code: 409), Internal Server Error (HTTP Status Code: 500), Service Unavailable (HTTP Status Code:503), Gateway Timeout (HTTP Status Code: 504).",
				Type:        proto.ColumnType_STRING,
				Transform:   transform.FromField("SubStatus.Value").Transform(transform.ToString),
			},

			// JSON fields
			{
				Name:        "authorization_info", // Since "authorization" is a reserved keyword in PostgreSQL, we had to rename it and use an alternative column name.
				Description: "The sender authorization information.",
				Type:        proto.ColumnType_JSON,
				Transform:   transform.FromField("Authorization"),
			},
			{
				Name:        "claims",
				Description: "Key value pairs to identify ARM permissions.",
				Type:        proto.ColumnType_JSON,
			},
			{
				Name:        "http_request",
				Description: "The HTTP request info. Usually includes the 'clientRequestId', 'clientIpAddress' (IP address of the user who initiated the event) and 'method' (HTTP method e.g. PUT).",
				Type:        proto.ColumnType_JSON,
				Transform:   transform.FromField("HTTPRequest"),
			},
			{
				Name:        "properties",
				Description: "The set of <Key, Value> pairs (usually a Dictionary<String, String>) that includes details about the event.",
				Type:        proto.ColumnType_JSON,
			},

			// Steampipe standard columns
			{
				Name:        "title",
				Description: ColumnDescriptionTitle,
				Type:        proto.ColumnType_STRING,
				Transform:   transform.FromField("EventName.Value"),
			},

			// Azure standard columns
			{
				Name:        "resource_group",
				Description: ColumnDescriptionResourceGroup,
				Type:        proto.ColumnType_STRING,
				Transform:   transform.FromField("ResourceGroupName"),
			},
		}),
	}
}

//// LIST FUNCTION

func listMonitorActivityLogEvents(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	session, err := GetNewSession(ctx, d, "MANAGEMENT")
	if err != nil {
		return nil, err
	}
	subscriptionID := session.SubscriptionID

	client := insights.NewActivityLogsClientWithBaseURI(session.ResourceManagerEndpoint, subscriptionID)
	client.Authorizer = session.Authorizer

	filter := buildActivityLogFilter(d.Quals)

	result, err := client.List(ctx, filter, "")
	if err != nil {
		plugin.Logger(ctx).Error("azure_monitor_activity_log_event.listMonitorActivityLogEvents", "api_error", err)
		return nil, err
	}

	for _, event := range result.Values() {
		d.StreamListItem(ctx, event)

		// Check if context has been cancelled or if the limit has been hit (if specified)
		// if there is a limit, it will return the number of rows required to reach this limit
		if d.RowsRemaining(ctx) == 0 {
			return nil, nil
		}
	}

	for result.NotDone() {
		err = result.NextWithContext(ctx)
		if err != nil {
			return nil, err
		}

		for _, event := range result.Values() {
			d.StreamListItem(ctx, event)

			// Check if context has been cancelled or if the limit has been hit (if specified)
			// if there is a limit, it will return the number of rows required to reach this limit
			if d.RowsRemaining(ctx) == 0 {
				return nil, nil
			}
		}
	}

	return nil, err
}

//// UTILITY FUNCTION

func buildActivityLogFilter(quals plugin.KeyColumnQualMap) string {
	filter := ""

	filterQuals := map[string]string{
		"event_timestamp":        "eventTimestamp",
		"resource_group":         "resourceGroupName",
		"correlation_id":         "correlationId",
		"resource_id":            "resourceUri",
		"resource_provider_name": "resourceProvider",
	}

	for columnName, filterName := range filterQuals {

		/*
		   The API input must include the Event Timestamp value to filter events. If the user provides an event_timestamp value in the where clause, we use that value. Otherwise, we set it to the past 90 days from the current date because the API can only return events from the last 90 days.
		*/
		if columnName == "event_timestamp" && quals[columnName] != nil {
			for _, q := range quals[columnName].Quals {
				evTime := q.Value.GetTimestampValue().AsTime().Format(time.RFC3339)
				if filter == "" {
					switch q.Operator {
					case ">", ">=":
						filter = filterName + " ge " + evTime
					case "<", "<=":
						filter = filterName + " le " + evTime
					}
				} else {
					switch q.Operator {
					case ">", ">=":
						filter += " and " + filterName + " ge " + evTime
					case "<", "<=":
						filter += " and " + filterName + " le " + evTime
					}
				}
			}
		} else if columnName == "event_timestamp" && quals[columnName] == nil {
			if filter == "" {
				filter = filterName + " ge " + time.Now().AddDate(0, 0, -90).Format(time.RFC3339)
			} else {
				filter = " and " + filterName + " ge " + time.Now().AddDate(0, 0, -90).Format(time.RFC3339)
			}
		} else {
			if quals[columnName] != nil {
				for _, q := range quals[columnName].Quals {
					if q.Operator == "=" {
						if filter == "" {
							filter = filterName + " eq " + q.Value.GetStringValue()
						} else {
							filter += " and " + filterName + " eq " + q.Value.GetStringValue()
						}
					}
				}
			}
		}

	}

	return filter
}
